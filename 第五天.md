# DAY 5 动规如何对误解的排列组合进行优化

## 2.7 动态规划：时间优化

## 概念作业

### 1， 请问动态规划的时间优化是基于什么做的？
* 基于对临界节点构成的有序序列进行减治，这里的有序是一个相对概念，只要是呈现某种规律性的线性序列都可以被称为有序，那我们就可以利用这个有序性避免遍历该序列中的所有元素，这就叫减治，这里减的就是对不需要遍历的无效状态空间，比如二分查找每次都折掉剩余状态空间的一半。
  
### 2，请问最大的时间复杂度是多大？这类问题计算机能解么？
* 排列时间复杂度n！和组合时间复杂度2^n 就是最大的时间复杂度。n代表的是问题规模，可见，随证n的上升，问题的时间复杂度回到一个无解的程度。那如何解决？当然是利用动态规划来解决这个问题，可以用动态规划将这个不可解问题转变为可解的问题。

## 2.8 动态规划：空间优化

## 概念作业

### 请问动态规划的先序和后续的空间优化有什么不同？
* 先序：当一个值被彻底用完之后，就没有利用价值了，就可以删除了。
* 后序：通过仅对重叠搜索的状态点进行存储。

### 代码题目
* FOR 先序的空间优化代码
* BFS 先序的空间优化代码 （例程进队DP做了优化，INDEG实际上也可以做优化）
* DFS 先序的空间优化代码
* DFS 后序的空间优化代码 （求f[n]时，f[n],f[n-1]都仅被搜索了一次，故而不需要做记忆化）

## 动态规划：五大类型

## 概念作业

### 1，写出全排列问题以及全组合问题的递推三要素即分析其重叠性，并分析为什么不做记忆化而用回溯去解决？
* 组合： 求[1,2,3,4,5]构成的所有组合
  * i，递推三要素
    * 1，状态语义：dp[i]表示在nums[i,nums.length-1]内的所有组合
      * a，边界状态： dp[n]=[]
      * b，目标状态：dp[0]
    * 2，递推公式： dp[i]=选择第i个数的所有组合 + 不选第i个数的所有组合
      * a，选择第i个数： 对于dp[i+1]所有的组合，全部添加nums[i]
      * b，不选第i个数： 对于dp[i+1]所有的组合，全保持不变
    * 3，递推方向
      * 先序FOR
      * 后序DFS
  * ii，重叠性分析
    * 1，实例分析：红色代表选择，下面两种决策做完后对应的状态都是dp[3] -->有重叠就是动态规划
      * a, dp[1r,2r,3,......] -->dp[3]
      * b, dp[1,2,3r,......] -->dp[3]
    * 2，原因分析
      * 原有的状态空间是2^i，现有的状态空间是i，但是每次递推国产我们还是考虑到了所有的情况，也就是说庞大的搜索空间被压缩了，孤儿必然回发生重叠性的手术
  * iii，记忆化分析





























