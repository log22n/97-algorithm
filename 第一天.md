# DAY 1 数据结构上的值传递

## 2.1 数据结构：四类结构
## 概念作业：

### 1，数据结构的逻辑结构和存储结构的关系是什么？
* 是抽象和具体的关系

### 2，数据结构的逻辑结构的两要素是什么？
* 逻辑结构研究点和边的关系，所以两要素为点和边
* 点：状态，边：递推
* 由此得四类数据结构：集，图，线，数

### 3， 树的边数和点数的关系是什么？
* 边数=点数-1 

### 4， 为什么所有的数据结构从值传递的角度来看都可以理解为DAG？
* 线性结构和树形结构的值传递可以是DAG的简化版
* 环图可以通过设置单调收敛的变量转换成DAG

### 5，常见的环图单调收敛算法
|单调收敛  |模板知识点   |状态   |单调   |收敛   |模板题目   |
|---|---|---|---|---|---|
|单点访问收敛   |tarjan算法   |state[node][vis]   |vis单调收敛   |vis最大值为1   |1192.查找集群内的【关键连接】   |
|全局访问收敛   |TSP算法   |state[node][globalVis]   |globalVis单调递增   |mask最大值为2^i-1   |847. 访问所有节点的最短路径   |
|距离收敛   |dijkstra算法   |state[node][dist]   |dist单调递减   |dist最小值为0   |LCP 35. 电动车游城市   |
|边数收敛   |欧拉回路   |state[node][edge]   |edge边数单调递减   |edge最小值为0   |2097.合法重新排列数对   |
|容量收敛   |DINIC   |   |流向终点容量递减   |随着迭代册数增加减少为0   |LCP 38. 守卫城堡   |

## 2.2 斐波那契：先序for
## 概念作业：

### 1, 值传递的结构：数据结构从值传递角度统一为DAG
* 数据结构的统一： 从值传递的角度来看，线性结构和树形结构的值传递可以是DAG的简化版，环图可以通过设置单调收敛的变量转换成DAG

### 2, 值传递的普适：从值传递的角度来看，DAG就是最复杂的情况，线、树的值传递是在DAG的简化，因此，掌握了对DAG的搜索，就掌握了其他数据结构的搜索。你能找到生活中以及前端、后端、数据库、深度学习中DAG的吗？
* 论文体系：如果说现代论文的引用体系就是DAG,那么可以说整个人类文明就是在DAG图上做前向传播，可以说可以说DAG无处不在,DAG图就是站在巨人的肩膀上的最好阐释
* 前端：数据响应式
* 后端：依赖注入
* 数据库：火山模型上的元组传递
* 深度学习：神经网络的前向传播与反向传播

### 3, 值传递的要素：只要是值传递，就一定涉及递推三要素，什么是值传递的递推三要素？
* 状态语义：f[i]无具体语义
  * 边界状态：f0]、f1]
  * 目标状态：f[n]
* 递推公式：f=fi-1]+f[i-2]
* 搜索方向
  * 先序：从已知→未知：FOR BFS DFS
  * 后序：从未知→已知：DFS

### 4, 值传递的顺序：视频里的先序与后序指的值传递的顺序，什么是先序和后序？自顶向下和自底向上这两个概念为什么尽量不要用？
* 先序和后序：这是值传递的顺序，这里的先序和后序适用于所有的数据结构，跟二叉树的先序遍历和后序遍历没有关系，这里的先序和后序是针对值传递而言。自顶向下和自底向上仅仅用来描述自上而下的树的值传递很合适，但是我们说值传递就是DAG,所以一定要用先序和后序
* 先序：已知点→未知点
* 后序：未知点→已知点

### 5, 值传递的收敛：从斐波那契里可以看出算法的单调收敛性指的是大问题d中[]只能依赖于小问题，而绝对不能依赖于对等的问题，这对你做快速排序和二分查找有什么启发呢？死循环的本质是什么呢？
* 写快速排序写不明白就是因为很多人的原问题是【L,r],结果拆成【L,m]和[+1，r]之后拆成的子问题的可能取了r,结果就是L,r]依然依赖于[L,r],就死循环了，当然很多同学二分也是这个问题，写不明白就是最后[L,r]死循环依赖于[l,r]了。
* 所有的死循环本质上就是没有把单调收敛做好

### 6, 值传递的递推：请写出在DAG图定义如下构成的递推公式，其实后面大家在做各种各样的d即问题的目标求值最常见就是这三种，只是最短路径会被翻译成成本最低的方案，最长路径会被翻译成收益最大的方案，路径个数会被翻译成符合条件的方案总数
* 到达cur的最短路径：dp[cur]=min(dp[pre]+len[pre][cur]):假设边的长度为len[pre][cur]
* 到达cur的最长路径：dp[cur]=max(dp[pre]+len[pre][cur]):假设边的长度为len[pre][cur]
* 到达cur的路径个数：dp[cur]=sum(dp[pre]):注意入度为0的点为边界点，其值为1

### 7, 动规定义：为什么斐波那契是动态规划？
* 因为状态点的值传递构成了DAG图，所以是动态规划，动态规划就是对DAG的搜索

### 8, 问题改编：尝试对斐波那契这个问题进行改编，如果递推式是求前两个数的最大值会出现什么情况？那么如何自己出题来解决这种问题？
* 会出现规律性的收敛，这样题目就没有意义了，我们可以通过设置随机变量来对抗这种收敛。
* 假设递推公式为dp[)=max(dp[i-1],dp[i-2]),那么序列就是01111111，就没必要往后推了
* 假设递推公式为dp[]=max(dp[i-1],dp[i-2])*random,这样才有递推下去的意义

### 代码作业
* 写出斐波那契的先序 FOR代码
  * python
``` python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0 or n == 1:
            return n
        dp = [0,1]
        for i in range(2, n+1):
            dp.append(dp[i-1] + dp[i-2])
        return dp[n]
```
  * C++
``` C++
class Solution {
public:
    int fib(int n) {
        if( n == 0 || n == 1) return n;
        vector<int> dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++) dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
};
```
